/*
 * generated by Xtext 2.32.0
 */
package org.xtext.example.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.services.VitsikaGrammarAccess;
import org.xtext.example.vitsika.AtaovyTask;
import org.xtext.example.vitsika.ClickAction;
import org.xtext.example.vitsika.Maty;
import org.xtext.example.vitsika.Model;
import org.xtext.example.vitsika.MoveAction;
import org.xtext.example.vitsika.OpenApplicationAction;
import org.xtext.example.vitsika.Surfer;
import org.xtext.example.vitsika.Typewrite;
import org.xtext.example.vitsika.VitsikaPackage;
import org.xtext.example.vitsika.WaitAction;
import org.xtext.example.vitsika.WifiCreate;
import org.xtext.example.vitsika.WordTypingAuto;

@SuppressWarnings("all")
public class VitsikaSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private VitsikaGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == VitsikaPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case VitsikaPackage.ATAOVY_TASK:
				sequence_AtaovyTask(context, (AtaovyTask) semanticObject); 
				return; 
			case VitsikaPackage.CLICK_ACTION:
				sequence_ClickAction(context, (ClickAction) semanticObject); 
				return; 
			case VitsikaPackage.MATY:
				sequence_Maty(context, (Maty) semanticObject); 
				return; 
			case VitsikaPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case VitsikaPackage.MOVE_ACTION:
				sequence_MoveAction(context, (MoveAction) semanticObject); 
				return; 
			case VitsikaPackage.OPEN_APPLICATION_ACTION:
				sequence_OpenApplicationAction(context, (OpenApplicationAction) semanticObject); 
				return; 
			case VitsikaPackage.SURFER:
				sequence_Surfer(context, (Surfer) semanticObject); 
				return; 
			case VitsikaPackage.TYPEWRITE:
				sequence_Typewrite(context, (Typewrite) semanticObject); 
				return; 
			case VitsikaPackage.WAIT_ACTION:
				sequence_WaitAction(context, (WaitAction) semanticObject); 
				return; 
			case VitsikaPackage.WIFI_CREATE:
				sequence_WifiCreate(context, (WifiCreate) semanticObject); 
				return; 
			case VitsikaPackage.WORD_TYPING_AUTO:
				sequence_WordTypingAuto(context, (WordTypingAuto) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     AtaovyTask returns AtaovyTask
	 *
	 * Constraint:
	 *     (actions+=Action actions+=Action*)
	 * </pre>
	 */
	protected void sequence_AtaovyTask(ISerializationContext context, AtaovyTask semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Action returns ClickAction
	 *     ClickAction returns ClickAction
	 *
	 * Constraint:
	 *     key=STRING
	 * </pre>
	 */
	protected void sequence_ClickAction(ISerializationContext context, ClickAction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VitsikaPackage.Literals.CLICK_ACTION__KEY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VitsikaPackage.Literals.CLICK_ACTION__KEY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getClickActionAccess().getKeySTRINGTerminalRuleCall_2_0(), semanticObject.getKey());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Action returns Maty
	 *     Maty returns Maty
	 *
	 * Constraint:
	 *     proc=STRING
	 * </pre>
	 */
	protected void sequence_Maty(ISerializationContext context, Maty semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VitsikaPackage.Literals.MATY__PROC) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VitsikaPackage.Literals.MATY__PROC));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMatyAccess().getProcSTRINGTerminalRuleCall_2_0(), semanticObject.getProc());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     task=AtaovyTask
	 * </pre>
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VitsikaPackage.Literals.MODEL__TASK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VitsikaPackage.Literals.MODEL__TASK));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getModelAccess().getTaskAtaovyTaskParserRuleCall_0(), semanticObject.getTask());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Action returns MoveAction
	 *     MoveAction returns MoveAction
	 *
	 * Constraint:
	 *     (X=INT Y=INT)
	 * </pre>
	 */
	protected void sequence_MoveAction(ISerializationContext context, MoveAction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VitsikaPackage.Literals.MOVE_ACTION__X) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VitsikaPackage.Literals.MOVE_ACTION__X));
			if (transientValues.isValueTransient(semanticObject, VitsikaPackage.Literals.MOVE_ACTION__Y) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VitsikaPackage.Literals.MOVE_ACTION__Y));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMoveActionAccess().getXINTTerminalRuleCall_2_0(), semanticObject.getX());
		feeder.accept(grammarAccess.getMoveActionAccess().getYINTTerminalRuleCall_4_0(), semanticObject.getY());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Action returns OpenApplicationAction
	 *     OpenApplicationAction returns OpenApplicationAction
	 *
	 * Constraint:
	 *     (applications+=ID applications+=ID*)
	 * </pre>
	 */
	protected void sequence_OpenApplicationAction(ISerializationContext context, OpenApplicationAction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Action returns Surfer
	 *     Surfer returns Surfer
	 *
	 * Constraint:
	 *     url=STRING
	 * </pre>
	 */
	protected void sequence_Surfer(ISerializationContext context, Surfer semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VitsikaPackage.Literals.SURFER__URL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VitsikaPackage.Literals.SURFER__URL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSurferAccess().getUrlSTRINGTerminalRuleCall_2_0(), semanticObject.getUrl());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Action returns Typewrite
	 *     Typewrite returns Typewrite
	 *
	 * Constraint:
	 *     soratra=STRING
	 * </pre>
	 */
	protected void sequence_Typewrite(ISerializationContext context, Typewrite semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VitsikaPackage.Literals.TYPEWRITE__SORATRA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VitsikaPackage.Literals.TYPEWRITE__SORATRA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypewriteAccess().getSoratraSTRINGTerminalRuleCall_2_0(), semanticObject.getSoratra());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Action returns WaitAction
	 *     WaitAction returns WaitAction
	 *
	 * Constraint:
	 *     (duration=INT (unit='s' | unit='m' | unit='h'))
	 * </pre>
	 */
	protected void sequence_WaitAction(ISerializationContext context, WaitAction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Action returns WifiCreate
	 *     WifiCreate returns WifiCreate
	 *
	 * Constraint:
	 *     (ssid=STRING passwd=STRING)
	 * </pre>
	 */
	protected void sequence_WifiCreate(ISerializationContext context, WifiCreate semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VitsikaPackage.Literals.WIFI_CREATE__SSID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VitsikaPackage.Literals.WIFI_CREATE__SSID));
			if (transientValues.isValueTransient(semanticObject, VitsikaPackage.Literals.WIFI_CREATE__PASSWD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VitsikaPackage.Literals.WIFI_CREATE__PASSWD));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWifiCreateAccess().getSsidSTRINGTerminalRuleCall_2_0(), semanticObject.getSsid());
		feeder.accept(grammarAccess.getWifiCreateAccess().getPasswdSTRINGTerminalRuleCall_4_0(), semanticObject.getPasswd());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Action returns WordTypingAuto
	 *     WordTypingAuto returns WordTypingAuto
	 *
	 * Constraint:
	 *     teny=STRING
	 * </pre>
	 */
	protected void sequence_WordTypingAuto(ISerializationContext context, WordTypingAuto semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VitsikaPackage.Literals.WORD_TYPING_AUTO__TENY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VitsikaPackage.Literals.WORD_TYPING_AUTO__TENY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWordTypingAutoAccess().getTenySTRINGTerminalRuleCall_2_0(), semanticObject.getTeny());
		feeder.finish();
	}
	
	
}
